#+title: SDL2 backend architecture
#+author: Daniel 'jackdaniel' KochmaÅ„ski
#+date: [2022-04-12 wto]

* Introduction

SDL2 is a fine choice for an interactive and portable backend. The abstraction
is thin and the library supports all major operating systems.  The main
limitation of the library is that it is not thread safe - all SDL2 functions
are expected to be called from a single thread (pushing events is an
exception).

In Common Lisp ecosystem there is a library ~cl-sdl2~ that proposes some
abstractions over a "raw" SDL2 library. This backend relies on ~cl-sdl2~ for
ffi bindings (generated with autowrap) provided by it, but I will mostly
ignore ~cl-sdl2~ abstractions (some are used as a temporary measure).

This document purpose is to emphasize important features that each backend
must or should implement. Many sdl2-specific details are not explained and the
reader should read the code to understand them. Keep in mind that most of
these recommendations are a result of figuring things out while writing this
backend - this is not a definitive guide.

* Syntactic sugar

There are two approaches to ensure that SDL2 runs in a single thread.

1. have a singular loop and communicate with it using a thread-safe channel
2. assume that the environment is single-threaded

McCLIM works fine with either model. That demands from the syntactic sugar to
enable either style of interaction. For the multithreaded environment some
synchronization primitives are introduced (most notably a condition variable
to notify that the display server is already initialized).

#+begin_src lisp
  (defvar *initialized-p* nil)
  (defvar *initialized-cv* (clim-sys:make-condition-variable))
  (defvar *initialized-lock* (clim-sys:make-lock "SDL2 init cv lock"))

  (defun %init-sdl2 ()
    (unless *initialized-p*
      (sdl2-ffi.functions:sdl-init (autowrap:mask-apply 'sdl-init-flags '(:everything)))
      (setf *initialized-p* (clim-sys:current-process)) ; important
      (clim-sys:condition-notify *initialized-cv*)
      (log:info "Hello!")))

  (defun %quit-sdl2 ()
    (when *initialized-p*
      (log:info "Good bye.")
      (setf *initialized-p* nil)
      (sdl2-ffi.functions:sdl-quit)))

  (defun %read-sdl2 (event timeout)
    (let ((rc (if (null timeout)
                  (sdl2-ffi.functions:sdl-wait-event event)
                  (sdl2-ffi.functions:sdl-wait-event-timeout event timeout))))
      (= rc 1)))

  ;;; This implements semantics of process-next-event but without distributing
  ;;; the event - there is no need for the port argument.
  (defun %next-sdl2 (wait-function timeout)
    (when (maybe-funcall wait-function)
      (return-from %next-sdl2 (values nil :wait-function)))
    (sdl2:with-sdl-event (event)
      (alx:if-let ((ev (%read-sdl2 event timeout)))
        (let ((event-type (sdl2:get-event-type event)))
          (values (handle-sdl2-event event-type event) event-type))
        (if (maybe-funcall wait-function)
            (values nil :wait-function)
            (values nil :timeout)))))
#+end_src

The function ~handle-sdl2-event~ is used to implement event handling. When
function that reads events calls ~handle-sdl2-event~ to dispatch on them.
Methods for this function are defined with a macro ~define-sdl2-handler~.  For
example:

#+begin_src lisp
  ;;; User-requested exit - this event is usually signaled when the last window
  ;;; is closed (in addition to windowevent/close), but may be also prompted by
  ;;; the window manager or an interrupt. The application may ignore it.
  (defvar *quit-stops-the-port-p* nil)

  (define-sdl2-handler (event :quit) ()
    (log:info "Quit requested... ~a"
              (if *quit-stops-the-port-p* "signaling" "ignoring"))
    (when *quit-stops-the-port-p*
      (signal 'sdl2-exit-port)))
#+end_src

The second argument to the macro is a list of arguments. The event is
destructured (with the library ~autowrap~) to estabilish a lexical context for
the handler body. For details see ~expand-handler-for-core-event~.

To communicate with the main thread another convenience macro is defined:
~define-sdl2-request~. For example:

#+begin_src lisp
  (define-sdl2-request sdl2-exit-port ()
    (signal 'sdl2-exit-port))
#+end_src

This macro registers an user event type, defines a function ~sdl2-exit-port~
that queues event of that type and a method on ~handle-sdl2-event~ that
implements the body. In single-processing mode handler is called directly.

The arglist is similar as with the "system events" but we expand them by a
different mechanism. Request lambda list is (,@args &key synchronize) - the
keyword argument allows to wait for the result returned by the handler.

#+begin_src lisp
  ;;; This function should be called with synchronization as a timeout - it will
  ;;; return :pong only when the event is processed (so the loop is processing).
  (define-sdl2-request sdl2-ping ()
    :pong)

  ;;; This function is for testing.
  ;;; WARNING this will freeze the event loop for requested amount of time.
  (define-sdl2-request sdl2-delay (ms)
    (sdl2-ffi.functions:sdl-delay ms)
    :done)
#+end_src

#+begin_example
  MCCLIM-SDL2> (sdl2-ping)                       ;; NIL
  MCCLIM-SDL2> (sdl2-ping :synchronize t)        ;; :PONG
  MCCLIM-SDL2> (sdl2-delay 1000)                 ;; NIL
  MCCLIM-SDL2> (sdl2-delay 1000 :synchronize .5) ;; NIL
  MCCLIM-SDL2> (sdl2-delay 1000 :synchronize 2)  ;; :DONE
#+end_example

That concludes the syntactic sugar used by this project. The see
implementation details see the file ~utilities.lisp~.

* Resource managament

When working with FFI libraries some memory allocated by us is not entirely
under our control. That means that when the resource is no longer needed we
need to free the memory.

# CLIM provides an [[http://bauhh.dyndns.org:8000/clim-spec/B-1.html][abstraction]] that makes this easier.  ~defresource~ defines
# an object pool that allows object reuse. That won't do because there is no
# way to remove a single object from the pool and there are no explicit
# destructors. That's why we are going to cook something of our own.

Usually we will want to find the resource associated with a CLIM object (for
example with a design). When sending events SDL2 addresses windows with the
window id, so we also need to maintain a map from the id to the resource.

#+begin_src lisp
  (defclass resource-manager-mixin ()
    ((clim->resource                      ; clim (obj) -> resource
      :allocation :class
      :initform (make-hash-table))
     (sdl2->resource                      ; sdl2 (int) -> resource
      :allocation :class
      :initform (make-hash-table))))

  (defmacro ensure-resource ((manager clim-object) &body body)
    (alx:once-only (manager)
      `(let ((^clim-object ,clim-object))
         (or (find-clim-resource ,manager ^clim-object)
             (register-resource ,manager (progn ,@body))))))

  (defun register-resource (manager object)
    (with-slots (clim->resource sdl2->resource) manager
      (let ((resource-id (sdl2-resource-id object))
            (clim-object (sdl2-resource-clim-object object)))
        (assert (and clim-object (null (gethash clim-object clim->resource))))
        (when resource-id
          (setf (gethash resource-id sdl2->resource) object))
        (setf (gethash clim-object clim->resource) object))))

  (defun deregister-resource (manager object)
    (with-slots (clim->resource sdl2->resource) manager
      (remhash (sdl2-resource-id object) sdl2->resource)
      (remhash (sdl2-resource-clim-object object) clim->resource))
    nil)

  (defun find-clim-resource (manager clim-object)
    (let ((object (gethash clim-object (slot-value manager 'clim->resource))))
      (if (and object (sdl2-resource-deallocated-p object))
          (deregister-resource object manager)
          object)))

  (defun find-sdl2-resource (manager resource-id)
    (let ((object (gethash resource-id (slot-value manager 'sdl2->resource))))
      (if (and object (sdl2-resource-deallocated-p object))
          (deregister-resource object manager)
          object)))

  (defun free-resources (manager)
    (loop with clim->resource = (slot-value manager 'clim->resource)
          with sdl2->resource = (slot-value manager 'sdl2->resource)
          for resource being each hash-value of clim->resource
          do (free-sdl2-object resource)
          finally (clrhash clim->resource)
                  (clrhash sdl2->resource)))
#+end_src

Finally we want to be able to map the resource to its CLIM object and its
(optional) ID. We have control over the wrapper layout, so we may store this
information directly with the instance.

#+begin_src lisp
  (defclass sdl2-resource ()
    ((deallocated-p :initform nil :accessor sdl2-resource-deallocated-p)
     (resource-id :initarg :resource-id :reader sdl2-resource-id) ;may be null
     (clim-object :initarg :clim-object :reader sdl2-resource-clim-object))
    (:default-initargs
     :resource-id nil
     :clim-object (error ":clim-object is a required argument.")))

  (defgeneric free-sdl2-resource (object)
    (:method :around ((object sdl2-resource))
      (unless (sdl2-resource-deallocated-p object)
        (call-next-method)
        (setf (sdl2-resource-deallocated-p object) t))
      nil))
#+end_src

The most important resources we are going to manage are windows:

#+begin_src lisp
  ;;; Mirror stands for a connection between the SDL2 window and McCLIM sheet.
  (defclass sdl2-mirror (sdl2-resource)
    ((window :initarg :window :reader sdl2-mirror-window)
     (clim-object :reader sdl2-mirror-sheet)))

  (defun make-sdl2-mirror (&key window-id window sheet)
    (make-instance 'sdl2-mirror :resource-id window-id
                                :clim-object sheet
                                :window window))

  (define-sdl2-request sdl2-create-mirror (sheet title x y width height flags)
    (let* ((flags (autowrap:mask-apply 'sdl-window-flags flags))
           (window (sdl2-ffi.functions:sdl-create-window
                    title x y width height flags))
           (id (sdl2-ffi.functions:sdl-get-window-id window)))
      (make-sdl2-mirror :window-id id :window window :sheet sheet)))

  (defmethod free-sdl2-resource ((object sdl2-mirror))
    (let ((window (sdl2-mirror-window object)))
      (sdl2-ffi.functions:sdl-destroy-window window)
      (autowrap:invalidate window)))
#+end_src

And the second resource are surfaces. For now we'll use them to represent RGBA
images created from patterns. They may be used for window icons, cursors and
in the case of a software renderer as an output framebuffer.

#+begin_src lisp
  ;;; Conveting designs to SDL2 surfaces is an operation that is required to
  ;;; produce the window icon, customize the pointer cursor, and in the case of
  ;;; a software renderer it may be used to draw on the sheet.
  ;;;
  ;;; This operation allocates foreign memory that must be freed afterwards. The
  ;;; caller is responsible for retaining the surface and freeing it when no
  ;;; longer necessary (i.e when the port or the window is destroyed).
  (defclass sdl2-image (sdl2-resource)
    ((clim-object :reader sdl2-image-design)
     (carray :initarg :carray :reader sdl2-image-carray)
     (surface :initarg :surface :reader sdl2-image-surface)))

  (defun make-sdl2-image (&key design surface carray)
    (make-instance 'sdl2-image :clim-object design :surface surface :carray carray))

  ;;; FIXME McCLIM should and will have more image formats ranging from
  ;;; black/white to full RGBA (like here). When we get to it then tthis
  ;;; function will need to account for other pattern types too.
  (define-sdl2-request sdl2-create-rgb-surface-from-image (design)
    (check-type design image-pattern)
    (let* ((array (pattern-array design))
           (width (pattern-width design))
           (height (pattern-height design))
           (depth 32)                     ; ^ pattern-depth
           (pitch (* 4 width)))
      (let* ((c-array (cffi:foreign-array-alloc array :uint32))
             (surface (sdl2-ffi.functions:sdl-create-rgb-surface-from
                       c-array width height depth pitch
                       #x00ff0000 #x0000ff00 #x000000ff #xff000000)))
        (make-sdl2-image :design design :surface surface :carray c-array))))

  (defmethod free-sdl2-resource ((object sdl2-image))
    (let ((surface (sdl2-image-surface object))
          (carray (sdl2-image-carray object)))
      (sdl2-ffi.functions:sdl-free-surface surface)
      (cffi:foreign-array-free carray)
      (autowrap:invalidate surface)))
#+end_src
